File: mmu.h
Line 97: Added the PTE_SH flag to distinguish between shared and non-shared
page tables

File: sysproc.c
Line 93: Added sys_procdump() method to add procdump as a syscall to access
in testcow.c

File: usys.S
Line 32: Added SYSCALL(procdump) to add procdump as a syscall to access
in testcow.c

File: syscall.c
Line 106: Added extern int sys_procdump(void) declaration
Line 130: Added [SYS_procdump] sys_procdump to syscalls array

File: syscall.h
Line 23: Defined sys_procdump and gave it a unique consecutive number

File: user.h
Line 26: Declared procdump(void) syscall

File: Makefile
Line 184: Added _testcow\ to run testcow.c
Line 257: Added testcow.c\

File: testcow.c
Line 11-15: I declare SIZE as 4096 + 1 to make sure we'll change 2 pages
and not just 1. I use malloc to assign SIZE amount of memory to char* space 
and then call procdump to print the parent's information before the fork call.
Line 18: This is where I call fork() which in turn will call my cow() method
Line 19-29: This is the child process' code and it first calls procdump to print
its information before changing values. I then use a for loop to iterate through
space and update each value by incrementing it by 1. I then call procdump again
to print information after changing the values and then I exit(). 
Line 33-38: This is the parent process code which simply calls wait() to wait for
the child process to terminate before continuing. Finally we free space and exit()
from the parent process.

File: vm.c
Line 16-19: Declared and defind count_cow struct to keep a counter for how many 
process shared a certain page
Line 39: Called initlock() in seginit() to initialise my lock
Line 205-211: Added code to initialise the counter to 0 in inituvm() (this was 
done within acquiring and releasing a lock)
Line 267-273: Added code to initialise the counter to 0 in allocuvm() (inside the for 
loop at the end)
Line 304-323: Added code to deallocuvm() to check if the counter to the specified page
table is 0. If so, I use kfree to free the memory at v and make the ptw value 0.
Otherwise we decrement the counter and then check again if the counter's value is now 0.
If it is, we change the Parent's PDE to reflect it is now writable and not shared.
Line 399-436: This is where I implemented the cow() method which contains my implementation
of Copy on write. The method basically sets up kvm (setupkvm()), then loops through every page
and checks if pte exists and page is present. I then get the page address (inside the loop)
We then make the pte shared and not writable and then map child to parent's page. We then increment
the counter and lastly, (after the for loop) we reinstall TLB entries.
Line 440-507: This is where I implemented pagefault(). I basically get the rcr2() address first
which gives me the virtual address of the page that caused the fault. We make sure this address
is not 0. We then find the PTW using walkpgdir(). We make sure the pte is shared and present.
We then find the physical address. After this we check if the table is shared or not using the 
counter. If it is not shared we make the table writable and not shared using flags.
If it is shared then we create a new page table, copy contents of page table we have, change the
flags appropriately, insert the new PPN, and decrease the counter. Lastly, we reinstall TLB 
entries.

File: trap.c
Line 80-85: I check if the pagefault is caused by user code or not and if it is, we call our
pagefault() method.

File: defs.h
Line 188-189: We declare our cow and pagefault methods.

File: proc.c
Line 535-559: Here I updated procdump() to print out the necessary information needed. 
We first find the pde and then the pte. We then loop through the page table and check 
if each entry is present and is user. If it is, we find the physical address again. We
print the already acquire pa and va to the console. We then check if the entry is 
writable or not and print the corresponding 'y' or 'n'.



